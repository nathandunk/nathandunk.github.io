<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.0.1">Jekyll</generator><link href="http://nathandunkelberger.com/feed.xml" rel="self" type="application/atom+xml" /><link href="http://nathandunkelberger.com/" rel="alternate" type="text/html" /><updated>2021-12-16T20:46:15-06:00</updated><id>http://nathandunkelberger.com/feed.xml</id><title type="html">Nathan Dunkelberger</title><subtitle>I am a PhD student in the MAHI Lab at Rice University designing the next generation of assistive robotics.</subtitle><author><name>Nathan Dunkelberger</name></author><entry><title type="html">MAHI Open Exo Software</title><link href="http://nathandunkelberger.com/Portfolio/MOE_Software" rel="alternate" type="text/html" title="MAHI Open Exo Software" /><published>2021-10-03T00:00:00-05:00</published><updated>2021-10-03T00:00:00-05:00</updated><id>http://nathandunkelberger.com/Portfolio/MOE_software</id><content type="html" xml:base="http://nathandunkelberger.com/Portfolio/MOE_Software">&lt;h1 id=&quot;mahi-open-exo-software&quot;&gt;MAHI Open Exo Software&lt;/h1&gt;

&lt;p&gt;The MAHI Open Exo runs based on a &lt;a href=&quot;https://github.com/mahilab/moe&quot;&gt;c++ library&lt;/a&gt; that I have developed based on the MEII software library that was used before. This library is set up to interface with a number of DAQs that we have in our lab. The library also abstracts out all necessary conversions so that the user can provide inputs and read outputs directly in useful units. This includes converting encoder position and velocity readings to radians for all joints, accounting for gear ratios, as well as allowing the user to provide command torques to the robot, accounting for conversions from voltage output, to current output, to motor torque output which is then amplified through a gear ratio. An example of some of the high-level commands are shown below.&lt;/p&gt;

&lt;div class=&quot;language-cpp highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    &lt;span class=&quot;c1&quot;&gt;// enables communication with the daq and turns on the motor drivers&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;moe&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;enable&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
    
    &lt;span class=&quot;c1&quot;&gt;// updates the internal model of the robot's state&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;moe&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;update&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;

    &lt;span class=&quot;c1&quot;&gt;// get all joint positions, or just get the position from a single joint&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;moe&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;get_joint_positions&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;moe&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;get_joint_position&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    
    &lt;span class=&quot;c1&quot;&gt;// set all raw joint torques &lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;moe&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;set_raw_joint_torques&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;command_torques&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;

    &lt;span class=&quot;c1&quot;&gt;// set torques based on tuned PD gains for position control&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;moe&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;set_pos_ctrl_torques&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;reference&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;

    &lt;span class=&quot;c1&quot;&gt;// checks the status of all important states to make sure &lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// that the robot is in a safe configuration&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;moe&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;any_limit_exceeded&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;One of the most important features of this library is that it is tightly integrated with the MOE simulation that has been created to work alongside the robot. Through a simple command line flag which can be added to any program, the program will communcate with the MOE simulation instead of attempting to connect to the appropriate DAQ. This is extremely valuable because it lets the user test any program before running it on the actual robot. Not only does this help verify that the program is doing what it was intended to do, but because it includes accurate dynamics of the robot, control algorithms can be tuned using the simulation so that we know they will run effectively the first time on the real robot.&lt;/p&gt;</content><author><name>Nathan Dunkelberger</name></author><category term="portfolio" /><category term="robotics" /><category term="software" /><category term="simulation" /><summary type="html">MAHI Open Exo Software</summary></entry><entry><title type="html">DH Convention Visualizer</title><link href="http://nathandunkelberger.com/Portfolio/DH_Visualizer" rel="alternate" type="text/html" title="DH Convention Visualizer" /><published>2021-10-03T00:00:00-05:00</published><updated>2021-10-03T00:00:00-05:00</updated><id>http://nathandunkelberger.com/Portfolio/DH_Convention_Visualizer</id><content type="html" xml:base="http://nathandunkelberger.com/Portfolio/DH_Visualizer">&lt;h1 id=&quot;denavit-hartenberg-parameter-visualization&quot;&gt;Denavit Hartenberg Parameter Visualization&lt;/h1&gt;
&lt;p&gt;When I took my first intro to robotics course, I realized one of the hardest concepts to understand was the Denavit-Hartenberg (DH) convention. While not as common in modern robotics, I feel that DH convention is a powerful tool to find closed-form solutions for both kinematics and dynamics, which helps demistify the nature of these problems for beginner-level roboticists. However, anyone who has learned DH convention is likely familiar with one of the most confusing figures I have seen.&lt;/p&gt;

&lt;p&gt;In my opinion, the hardest part of learning DH convention is visualizing what the different DH parameters actually mean, and understanding what a resulting robot looks like given a DH table. When I was learning the concept, I made my own 3D visualization tool in Matlab that could display all coordinate frames given a DH table. I decided that I wanted to make this available for anyone to use to learn the DH convention, and so I expanded this to a python tool as a part of my project for the class, but then decided to remake it using Unity so that it could have a more efficient UI, and so that I could add c++ functionality through dlls if I wanted. The result is shown in the picture below, where the user can add/remove joints, use sliders to change different variables, and the code that runs this is available in this &lt;a href=&quot;https://github.com/nathandunk/DHviz2&quot;&gt;github repository&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;\img\DH_Viz.JPG&quot; alt=&quot;DH Visualizer&quot; /&gt;&lt;/p&gt;</content><author><name>Nathan Dunkelberger</name></author><category term="portfolio" /><category term="robotics" /><category term="dynamics" /><category term="simulation" /><category term="kinematics" /><category term="dh" /><summary type="html">Denavit Hartenberg Parameter Visualization When I took my first intro to robotics course, I realized one of the hardest concepts to understand was the Denavit-Hartenberg (DH) convention. While not as common in modern robotics, I feel that DH convention is a powerful tool to find closed-form solutions for both kinematics and dynamics, which helps demistify the nature of these problems for beginner-level roboticists. However, anyone who has learned DH convention is likely familiar with one of the most confusing figures I have seen.</summary></entry><entry><title type="html">MAHI Open Exo Hardware Design</title><link href="http://nathandunkelberger.com/Portfolio/MOE_Hardware_Design" rel="alternate" type="text/html" title="MAHI Open Exo Hardware Design" /><published>2021-10-03T00:00:00-05:00</published><updated>2021-10-03T00:00:00-05:00</updated><id>http://nathandunkelberger.com/Portfolio/MOE_hardware_design</id><content type="html" xml:base="http://nathandunkelberger.com/Portfolio/MOE_Hardware_Design">&lt;h1 id=&quot;mahi-open-exo-hardware-design&quot;&gt;MAHI Open Exo Hardware Design&lt;/h1&gt;
&lt;p&gt;As I had mentioned in my &lt;a href=&quot;/Portfolio/MEII_sim&quot;&gt;Mahi Exo II Sim page&lt;/a&gt;, the MAHI Exo II was designed quite a while ago. Some of the features that had made it useful in the past also became it’s downfall. To use more advanced control algorithms, we needed to have an accurate and efficient dynamic model of the robot. While I &lt;em&gt;was&lt;/em&gt; able to derive the dynamic equations for the MAHI Exo II, it took far too long (~200 us) to calculate the eoms to perform any kind of realtime model-based control using the model. The complexity was due to the MEII using a parallel mechanism for 3 of the 5 degrees of freedom.&lt;/p&gt;

&lt;p&gt;We decided to combine the OpenWrist, developed in the &lt;a href=&quot;https://mahilab.rice.edu&quot;&gt;MAHI lab&lt;/a&gt;, with the elbow joint of the MEII to create a robot that had the same number of effective degrees of freedom as the MEII, but was in a serial configuration, and therefore had straightforward dynamics. This new design allowed dynamics to be solved 10x faster, at roughly 20us per solution. This design work was done by myself, and my coworker Jeff Berning, with some help from undergraduate research assistants that we mentored.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/MOE_pic.jpg&quot; alt=&quot;MOE Picture&quot; /&gt;&lt;/p&gt;

&lt;p&gt;The first part of this design consisted of making several parts that would interface the two different subcomponents. This design was important, especially because we added a lockable, passive degree of freedom to the robot to adjust for 90th percentile Male and Female arm sizes.&lt;/p&gt;

&lt;p&gt;In the process of this redesign, we realized that there were many design components that had been poorly designed before. Some of the problems that we fixed include:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Many components were secured by epoxy, rather than interfacing geometry.&lt;/li&gt;
  &lt;li&gt;Several fasteners interfaces had been designed with loose-fit holes that allowed a non-negligible amount of movement.&lt;/li&gt;
  &lt;li&gt;Pieces interfacing with bearings were touching both the stationary, and moving parts of the bearing.&lt;/li&gt;
&lt;/ul&gt;</content><author><name>Nathan Dunkelberger</name></author><category term="portfolio" /><category term="robotics" /><category term="dynamics" /><category term="hardware" /><category term="kinematics" /><summary type="html">MAHI Open Exo Hardware Design As I had mentioned in my Mahi Exo II Sim page, the MAHI Exo II was designed quite a while ago. Some of the features that had made it useful in the past also became it’s downfall. To use more advanced control algorithms, we needed to have an accurate and efficient dynamic model of the robot. While I was able to derive the dynamic equations for the MAHI Exo II, it took far too long (~200 us) to calculate the eoms to perform any kind of realtime model-based control using the model. The complexity was due to the MEII using a parallel mechanism for 3 of the 5 degrees of freedom.</summary></entry><entry><title type="html">MAHI Exo II Dynamics and Simulation</title><link href="http://nathandunkelberger.com/Portfolio/MEII_sim" rel="alternate" type="text/html" title="MAHI Exo II Dynamics and Simulation" /><published>2021-10-03T00:00:00-05:00</published><updated>2021-10-03T00:00:00-05:00</updated><id>http://nathandunkelberger.com/Portfolio/MEII_sim</id><content type="html" xml:base="http://nathandunkelberger.com/Portfolio/MEII_sim">&lt;h1 id=&quot;mahi-exo-ii-dynamics-and-simulation&quot;&gt;Mahi Exo II Dynamics and Simulation&lt;/h1&gt;
&lt;p&gt;In &lt;a href=&quot;https://mahilab.rice.edu&quot;&gt;my lab&lt;/a&gt;, one of the main robots that has been used for experiments is the Mahi Exo II (MEII). This robot is a 5-DOF robot that can actuate the user’s elbow flexion/extension, forearm pronation/supination, wrist flexion/extension, and wrist radial/ulnar deviation, as well as one DOF that is adjustable for the user’s arm length.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/MAHI_Exo_II.png&quot; alt=&quot;MEII&quot; /&gt;&lt;/p&gt;

&lt;p&gt;One of the main features of this robot is that it has a parallel mechanism that drives the last 3 DOFs. This provides the benefit of moving the weight back in the robot, but complicates control, because we cannot simply use a PD controller for every anatomical joint to follow a trajectory.&lt;/p&gt;

&lt;p&gt;Using the kinematics and the constraints of the parallel mechanism, we can compute the required torque to effectively provide torque to the anatomical DOFs, even though we are providing them to the non-anatomical parallel DOFs. See &lt;a href=&quot;/files/MEII_Kinematics.pdf&quot;&gt;this document&lt;/a&gt; for more information about kinematic modeling. Essentially, there are 14 total DOFs on the robot, 9 of them passive, and 9 constraints, so that we can derive the motion we want on the 5 DOFs that are important to us.&lt;/p&gt;

&lt;p&gt;I had been using the robot for research, but when COVID-19 arrived, I was unable to use the robot in person, so I developed a simulation for the MEII so that I could test software at home. The parallel kinematics means that there is no closed-form solution for the dynamics of the MEII. Using &lt;a href=&quot;https://ieeexplore.ieee.org/document/973894/figures#figures&quot;&gt;this paper&lt;/a&gt;, I was able to transform the dynamics of the 14 individual DOFs to the 5 DOFs that were important for me.&lt;/p&gt;

&lt;p&gt;With the solution, I created a simulation using the Unity game engine. I was able to export the solidworks files as .objs, import them into Unity, and set them to move given variables. Separately, I set up a c++ program that would calculate the accelerations of each of the joints, and integrate through time at a 1kHz loop rate. This was loaded as a dll into Unity and the resulting movements were visualized as mentioned. All code that was used to do this is available &lt;a href=&quot;https://github.com/mahilab/MEIISim&quot;&gt;here&lt;/a&gt;, with dynamics calculated in matlab, EOMs converted to a usable format using python, c++ code to run the simulation, and unity environment to communicate with simulation and visualize results.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/meii_sim_rom_demo.gif&quot; alt=&quot;Mahi Exo II Sim Demo&quot; /&gt;&lt;/p&gt;

&lt;p&gt;In my &lt;a href=&quot;https://github.com/mahilab/MEII&quot;&gt;repository&lt;/a&gt; that is used to run the MEII, I added a flag that I could input to any program that would reroute all daq commands (reading position/velocity and writing torque) to the simulation instead of the daq. Now, I can run anything that I can run on the real robot, in my own simulation!&lt;/p&gt;</content><author><name>Nathan Dunkelberger</name></author><category term="portfolio" /><category term="robotics" /><category term="dynamics" /><category term="simulation" /><category term="kinematics" /><category term="Solidworks" /><category term="C++" /><category term="python" /><summary type="html">Mahi Exo II Dynamics and Simulation In my lab, one of the main robots that has been used for experiments is the Mahi Exo II (MEII). This robot is a 5-DOF robot that can actuate the user’s elbow flexion/extension, forearm pronation/supination, wrist flexion/extension, and wrist radial/ulnar deviation, as well as one DOF that is adjustable for the user’s arm length.</summary></entry><entry><title type="html">MAHI Open Exo Simulation</title><link href="http://nathandunkelberger.com/Portfolio/MOE_Sim" rel="alternate" type="text/html" title="MAHI Open Exo Simulation" /><published>2021-10-03T00:00:00-05:00</published><updated>2021-10-03T00:00:00-05:00</updated><id>http://nathandunkelberger.com/Portfolio/MOE_sim</id><content type="html" xml:base="http://nathandunkelberger.com/Portfolio/MOE_Sim">&lt;h1 id=&quot;mahi-open-exo-simulation&quot;&gt;MAHI Open Exo Simulation&lt;/h1&gt;
&lt;p&gt;As my coworker and I were designing the MAHI Open Exo (MOE), we were simultaneously developing the software to control it. As we were still waiting on parts to be machined, and electronics to be finished, I wanted a way to make sure that our software was ready to use. As I had already developed a simulation for one of our previous robots, the MEII, I decided to make a simulation for our robot so that we could test our software (all code can be found &lt;a href=&quot;https://github.com/mahilab/MOE_sim&quot;&gt;here&lt;/a&gt;).&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/moe_sim_rom_demo.gif&quot; alt=&quot;Mahi Open Exo Sim Demo&quot; /&gt;&lt;/p&gt;

&lt;p&gt;After developing a simulation for the MEII, a 5 DOF parallel robot, developing a simulation for MOE, a 4 DOF serial robot was a significantly easier task. With this being a fully serial robot, dynamics could be explicitly found through iterative Newton-Euler equations. With this solution, all that was needed was to find mass properties for each of the successive joints on the robot.&lt;/p&gt;

&lt;p&gt;In the past, mass properties have been generated by selecting all relevant parts in Solidworks, and manually copying down mass properties to a c++ file to pull from. When design work has been completed, this is a valid option, but we were still in the process of iterating our designs. Because of this, I wrote a C# script using the Solidworks API to automatically generate the mass properties for each joint to a json format. Similar to the MEII simulation, I used a python script to generate c++ compatible files which could be compiled to run the simulation.&lt;/p&gt;</content><author><name>Nathan Dunkelberger</name></author><category term="portfolio" /><category term="robotics" /><category term="dynamics" /><category term="simulation" /><category term="kinematics" /><category term="Solidworks" /><category term="C#" /><category term="c++" /><category term="python" /><summary type="html">MAHI Open Exo Simulation As my coworker and I were designing the MAHI Open Exo (MOE), we were simultaneously developing the software to control it. As we were still waiting on parts to be machined, and electronics to be finished, I wanted a way to make sure that our software was ready to use. As I had already developed a simulation for one of our previous robots, the MEII, I decided to make a simulation for our robot so that we could test our software (all code can be found here).</summary></entry><entry><title type="html">FES C++ UART Interface Library</title><link href="http://nathandunkelberger.com/Portfolio/FES_library" rel="alternate" type="text/html" title="FES C++ UART Interface Library" /><published>2021-10-03T00:00:00-05:00</published><updated>2021-10-03T00:00:00-05:00</updated><id>http://nathandunkelberger.com/Portfolio/High-level_FES_library</id><content type="html" xml:base="http://nathandunkelberger.com/Portfolio/FES_library">&lt;h1 id=&quot;high-level-c-fes-library&quot;&gt;High-level C++ FES Library&lt;/h1&gt;
&lt;p&gt;I developed &lt;a href=&quot;https://github.com/mahilab/mahi-fes&quot;&gt;a library&lt;/a&gt; to run a research-grade Functional Electrical Stimulator System based on low-level UART control. This library facilitated my easy use of FES for coordinated use with the exoskeleton I am using to assist arm movements. One main feature of the library is a GUI that displays the current status of FES channels if being controlled externally, or allows for the direct control if desired. An example of the GUI is shown below.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/visualizer.gif&quot; alt=&quot;Visualizer&quot; /&gt;&lt;/p&gt;

&lt;p&gt;A full set of examples for how to use the library is shown &lt;a href=&quot;https://github.com/mahilab/mahi-fes/tree/master/examples&quot;&gt;here&lt;/a&gt;, but see below for some examples of improvements.&lt;/p&gt;

&lt;p&gt;The example code for how to control the simulator included a lot of code like the example below.&lt;/p&gt;

&lt;div class=&quot;language-cpp highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;new_time&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;old_time&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;100&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;){&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;chngevnt1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;5&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;open_loop&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;chngevnt1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;sizeof&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;chngevnt1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;/&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;sizeof&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;chngevnt1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;checksum&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;chngevnt1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;sizeof&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;chngevnt1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;/&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;sizeof&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;chngevnt1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)));&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;write&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;fd0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;chngevnt1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;sizeof&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;chngevnt1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;/&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;sizeof&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;chngevnt1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)));&lt;/span&gt;		
    &lt;span class=&quot;n&quot;&gt;old_time&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;new_time&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;My goal was to make a library that was much more human-readable and easily configurable. A similar control loop using my library looks like the following.&lt;/p&gt;

&lt;div class=&quot;language-cpp highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;while&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;!&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;stop&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// update the pulsewidth of each of the stimulation events&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;stim&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;set_amp&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;bicep&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;60&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;stim&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;write_pw&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;bicep&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;10&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;10&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;sin&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;t&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)));&lt;/span&gt;

    &lt;span class=&quot;c1&quot;&gt;// command the stimulation patterns to be sent to the stim board.&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// This is required whether using the gui or updating in code.&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;test_clock&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;restart&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;stim&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;update&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// wait for the loop to end&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;t&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;timer&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;wait&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;().&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;as_seconds&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;</content><author><name>Nathan Dunkelberger</name></author><category term="portfolio" /><category term="FES" /><category term="C++" /><category term="gui" /><category term="python" /><summary type="html">High-level C++ FES Library I developed a library to run a research-grade Functional Electrical Stimulator System based on low-level UART control. This library facilitated my easy use of FES for coordinated use with the exoskeleton I am using to assist arm movements. One main feature of the library is a GUI that displays the current status of FES channels if being controlled externally, or allows for the direct control if desired. An example of the GUI is shown below.</summary></entry><entry><title type="html">Miscellaneous Arduino Projects</title><link href="http://nathandunkelberger.com/Portfolio/Arduino_Miscellaneous" rel="alternate" type="text/html" title="Miscellaneous Arduino Projects" /><published>2021-10-03T00:00:00-05:00</published><updated>2021-10-03T00:00:00-05:00</updated><id>http://nathandunkelberger.com/Portfolio/Arduino_Misc</id><content type="html" xml:base="http://nathandunkelberger.com/Portfolio/Arduino_Miscellaneous">&lt;p&gt;&lt;strong&gt;3D printed 3 DOF servo robot&lt;/strong&gt; - I developed this 3D printed 3 DOF robot so that I could experiment with my development of automating of visualization of DH parameters. This 3R robot was designed and 3D printed by myself, and allows movement in 3D positional space with forward and inverse kinematics derived for control.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/3R_Real.jpg&quot; alt=&quot;3D Printed 3DOF Servo Robot&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;3D printed 3 DOF DC motor robot&lt;/strong&gt; - After developing my 3D printed servo-based robot, I realized that I wanted to go further and experiment with various control theories and algorithms. By switching to DC motors and using current amplifiers, I can directly provide output torques to each of the joints. Because of this, I am able to use classical formulations of dynamics, where I can provide torque inputs and predict what affect those should have on dynamics. To accomplish this, I also had to switch platforms form arduino to ESP32 so that I had true ADCs available, and to get a significantly faster clock speed. Along with this, I also made a simulation that could be used to simulate the dynamics, including mass properties, and torque inputs from the DC motors.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/3R.jpg&quot; alt=&quot;3D Printed 3DOF DC Motor Robot&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Wooden LED Display&lt;/strong&gt; - As a birthday gift, I made an LED display powered by an arduino that could display different messaged based on button presses. To dress up the LED display, I made a wooden display with drilled holes for the LEDs to display out of to make it more aesthetic.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/MessageBox.jpg&quot; alt=&quot;LED Message Box&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Two-wheeled balancing robot&lt;/strong&gt; - My first arduino project was building a two-wheeled balancing robot. This project consists of two DC motors enabling a robot to maintain its balance based on an onboard gyro to track position. I started this project based on a tutorial, but built my own 3D printed base, and adapted code to meet my needs.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/BalancingRobot.jpg&quot; alt=&quot;Balancing Robot&quot; /&gt;&lt;/p&gt;</content><author><name>Nathan Dunkelberger</name></author><category term="portfolio" /><category term="arduino" /><category term="C++" /><category term="hobby" /><summary type="html">3D printed 3 DOF servo robot - I developed this 3D printed 3 DOF robot so that I could experiment with my development of automating of visualization of DH parameters. This 3R robot was designed and 3D printed by myself, and allows movement in 3D positional space with forward and inverse kinematics derived for control.</summary></entry><entry><title type="html">Arduino Serial Plotter</title><link href="http://nathandunkelberger.com/Portfolio/Arduino_Serial_Plotter" rel="alternate" type="text/html" title="Arduino Serial Plotter" /><published>2021-10-03T00:00:00-05:00</published><updated>2021-10-03T00:00:00-05:00</updated><id>http://nathandunkelberger.com/Portfolio/Arduino_Serial_Plotter</id><content type="html" xml:base="http://nathandunkelberger.com/Portfolio/Arduino_Serial_Plotter">&lt;p&gt;Please check out the &lt;a href=&quot;www.github.com/nathandunk/BetterSerialPlotter&quot;&gt;github repository&lt;/a&gt; with more details, demos, and explanations!&lt;/p&gt;

&lt;h1 id=&quot;better-serial-plotter&quot;&gt;Better Serial Plotter&lt;/h1&gt;
&lt;p&gt;I have been using the Arduino platform for more than 5 years now. In many of my projects, I find myself wanting to use some kind of plotting feature to understand something about the status of my project. When the arduino serial plotter became available, I used it extensively, but anyone who has used it knows that is has some significant flaws (you can see the built-in interface &lt;a href=&quot;https://arduinogetstarted.com/tutorials/arduino-serial-plotter&quot;&gt;here&lt;/a&gt;). I set out to build my own application in C++ that would be a drop-in replacement for the arduino’s built in serial plotter, but with many more features.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/add_remove_variables.gif&quot; alt=&quot;Better Serial Plotter Demo&quot; /&gt;&lt;/p&gt;

&lt;p&gt;This project was important for me for several reasons. I saw it as something that could really assist me in my endeavors on the arduino platform, but I also imagined that others could find it just as useful as I could. I also used this opportunity to improve my C++ skills, and teach myself how to make software that could be distributed to the general public, different than most of my hobby projects. For my own practice, I decided to make the software available for Windows, Linux, and Mac.&lt;/p&gt;

&lt;p&gt;To my surprise, when I made it available, I had a few people reach out and say that they were really enjoyed using it, and requested features, or help setting it up themselves. This gave me further practice in maintaining and updating a publicly available codebase, and responding to requests form users.&lt;/p&gt;</content><author><name>Nathan Dunkelberger</name></author><category term="portfolio" /><category term="arduino" /><category term="C++" /><category term="serial" /><category term="GUI" /><summary type="html">Please check out the github repository with more details, demos, and explanations!</summary></entry><entry><title type="html">MAHI Open Exo Electronics Design</title><link href="http://nathandunkelberger.com/Portfolio/MOE_Electronics_Design" rel="alternate" type="text/html" title="MAHI Open Exo Electronics Design" /><published>2021-10-03T00:00:00-05:00</published><updated>2021-10-03T00:00:00-05:00</updated><id>http://nathandunkelberger.com/Portfolio/MOE_electronics_design</id><content type="html" xml:base="http://nathandunkelberger.com/Portfolio/MOE_Electronics_Design">&lt;h1 id=&quot;mahi-open-exo-pcb-design&quot;&gt;MAHI Open Exo PCB Design&lt;/h1&gt;
&lt;p&gt;In addition to &lt;a href=&quot;/Portfolio/MOE_Hardware_Design&quot;&gt;designing new hardware&lt;/a&gt;, I designed a PCB for the robot to replace the giant and expensive electronics box that powered our previous robot (the MEII). The PCB design was done using Autodesk Fusion 360.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/MOE_pcb.jpg&quot; alt=&quot;MOE PCB&quot; /&gt;&lt;/p&gt;

&lt;p&gt;The main brains of the PCB are four Maxon Escon 50/5 motor motor drivers to power the four maxon motors on the Mahi Open Exo. The design has two separate areas on the board, one side that has components that connect to the robot - encoder and motor connections - and the other that has components that connect to the daq -encoder, analog input, digital inputs and outputs.&lt;/p&gt;

&lt;p&gt;We are currently designing an enclosure so that the power supply can sit underneath the PCB, and to have a dedicated 120V wall input and switch for the system with emergency stop. There will also be a cooling duct so that there is sufficient airflow for the electronics.&lt;/p&gt;</content><author><name>Nathan Dunkelberger</name></author><category term="portfolio" /><category term="robotics" /><category term="electronics" /><category term="pcb" /><summary type="html">MAHI Open Exo PCB Design In addition to designing new hardware, I designed a PCB for the robot to replace the giant and expensive electronics box that powered our previous robot (the MEII). The PCB design was done using Autodesk Fusion 360.</summary></entry><entry><title type="html">Generalized Dynamics and Simulation</title><link href="http://nathandunkelberger.com/Portfolio/Generalized_Dynamics" rel="alternate" type="text/html" title="Generalized Dynamics and Simulation" /><published>2021-10-03T00:00:00-05:00</published><updated>2021-10-03T00:00:00-05:00</updated><id>http://nathandunkelberger.com/Portfolio/Generalized_Dynamics_Generator</id><content type="html" xml:base="http://nathandunkelberger.com/Portfolio/Generalized_Dynamics">&lt;h1 id=&quot;generalized-dynamics-and-simulation&quot;&gt;Generalized Dynamics and Simulation&lt;/h1&gt;
&lt;p&gt;The goal of this project for me was to do a deep dive into the dynamics and simulation of robots.
I have had to setup several simulations, through both classes and research, but wanted to get a better understanding for the underlying principles.
All of the code for this project is available on the &lt;a href=&quot;https://github.com/nathandunk/DHviz2&quot;&gt;github page&lt;/a&gt;. 
You can see the full result of this project in the gif below.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/dh_viz_sim.gif&quot; alt=&quot;DH simulating gif&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;goals&quot;&gt;Goals&lt;/h2&gt;
&lt;p&gt;The goals of this project were&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Generate and visualize kinematics from dh parameters in realtime&lt;/li&gt;
  &lt;li&gt;Automatically calculate governing equations of motion of a system from dh parameters&lt;/li&gt;
  &lt;li&gt;Simulate the developed equations of motion in realtime&lt;/li&gt;
  &lt;li&gt;Bonus: Be able to do this all in one session&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;dh-parameter-visualization&quot;&gt;DH Parameter Visualization&lt;/h1&gt;
&lt;p&gt;The first part of this project was to provide an interactive interface for someone to explore DH convention in an intuitive way. The interface lets you slide or input DH parameters to understand how the resulting coordinate systems change. I made something similar in matlab when I took my robotics course, and I think this tool would be especially useful to explain how this works in practice. I made the interface using Unity, and the equations that govern the visualization are from Introduction to Robotics Third Edition by John Craig.&lt;/p&gt;

&lt;h1 id=&quot;automatic-generate-equations-of-motion&quot;&gt;Automatic Generate Equations of Motion&lt;/h1&gt;
&lt;p&gt;The second goal of this project was to automatically calculate the equations of motion for the system given the DH parameters. This can be done given explicit equations also found in Introduction to Robitcs by Craig. This was implemented in Python using the Scipy toolkit. The resulting equations were then converted into c++ files that could calculate the EOM of a robot in realtime. To get the properties of the robot, I setup a json file with mass/inertia properties that describe the robot.&lt;/p&gt;

&lt;h1 id=&quot;simulate-eoms-in-realtime&quot;&gt;Simulate EOMs in realtime&lt;/h1&gt;
&lt;p&gt;Once those equations of motion were developed, I used system commands to get cmake to compile the code without leaving the program. Once that was done, I loaded the created dll into the unity simulation, and added open-loop torque controllers at each joint that could again be controlled using sliders to validate that the dynamics were generated correctly.&lt;/p&gt;</content><author><name>Nathan Dunkelberger</name></author><category term="portfolio" /><category term="robotics" /><category term="dynamics" /><category term="simulation" /><category term="kinematics" /><category term="dh" /><summary type="html">Generalized Dynamics and Simulation The goal of this project for me was to do a deep dive into the dynamics and simulation of robots. I have had to setup several simulations, through both classes and research, but wanted to get a better understanding for the underlying principles. All of the code for this project is available on the github page. You can see the full result of this project in the gif below.</summary></entry></feed>